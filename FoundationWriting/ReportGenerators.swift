//
//  ReportGenerators.swift
//  FoundationWriting
//
//  Created by Hans Axelsson on 7/15/25.
//
import Foundation

// MARK: - Markdown Report Generator

class MarkdownReportGenerator {
    private let data: ExportData
    
    init(data: ExportData) {
        self.data = data
    }
    
    func generateReport() async throws -> String {
        var markdown = ""
        
        // Title and metadata
        markdown += "# Writing Analysis Report\n\n"
        markdown += "_Generated on \(formatDate(data.generatedAt))_\n\n"
        markdown += "---\n\n"
        
        // Summary
        markdown += "## Summary\n\n"
        markdown += generateSummarySection()
        markdown += "\n"
        
        // Detailed Analysis
        if data.settings.includeAnalysis {
            markdown += "## Detailed Analysis\n\n"
            markdown += generateAnalysisSection()
            markdown += "\n"
        }
        
        // Improvement Suggestions
        if data.settings.includeSuggestions && !data.analysis.improvementSuggestions.isEmpty {
            markdown += "## Improvement Suggestions\n\n"
            markdown += generateSuggestionsSection()
            markdown += "\n"
        }
        
        // Learning Roadmap
        if data.settings.includeLearningProgress, let roadmap = data.roadmap {
            markdown += "## Personalized Learning Roadmap\n\n"
            markdown += generateRoadmapSection(roadmap)
            markdown += "\n"
        }
        
        // Original Text
        if data.settings.includeOriginalText && !data.originalText.isEmpty {
            markdown += "## Original Text\n\n"
            markdown += "```\n"
            markdown += data.originalText
            markdown += "\n```\n\n"
        }
        
        // Footer
        markdown += "---\n\n"
        markdown += "_Generated by Writing Coach App • Enhanced by Foundation Models_\n"
        
        return markdown
    }
    
    private func generateSummarySection() -> String {
        let metrics = data.analysis.metrics
        var summary = ""
        
        summary += "| Metric | Value |\n"
        summary += "|--------|-------|\n"
        summary += "| Readability Level | \(metrics.fleschKincaidLabel) (Grade \(String(format: "%.1f", metrics.fleschKincaidGrade))) |\n"
        summary += "| Average Sentence Length | \(String(format: "%.1f", metrics.averageSentenceLength)) words |\n"
        summary += "| Average Word Length | \(String(format: "%.1f", metrics.averageWordLength)) characters |\n"
        summary += "| Vocabulary Diversity | \(String(format: "%.0f%%", metrics.vocabularyDiversity * 100)) |\n"
        summary += "| Improvement Areas | \(data.analysis.improvementSuggestions.count) suggestions |\n\n"
        
        return summary
    }
    
    private func generateAnalysisSection() -> String {
        var analysis = ""
        
        analysis += "### Overall Assessment\n\n"
        analysis += "> \(data.analysis.assessment)\n\n"
        
        analysis += "### Methodology\n\n"
        analysis += data.analysis.methodology + "\n\n"
        
        return analysis
    }
    
    private func generateSuggestionsSection() -> String {
        var suggestions = ""
        
        for (index, suggestion) in data.analysis.improvementSuggestions.enumerated() {
            suggestions += "### \(index + 1). \(suggestion.title)\n\n"
            suggestions += "**Area:** \(suggestion.area.rawValue.capitalized)  \n"
            suggestions += "**Priority:** \(Int(suggestion.priority * 100))%  \n"
            suggestions += "**Learning Effort:** \(Int(suggestion.learningEffort * 100))%\n\n"
            
            suggestions += "\(suggestion.description)\n\n"
            
            suggestions += "**Before:**\n"
            suggestions += "> \(suggestion.beforeExample)\n\n"
            
            suggestions += "**After:**\n"
            suggestions += "> \(suggestion.afterExample)\n\n"
            
            if !suggestion.resources.isEmpty {
                suggestions += "**Recommended Resources:**\n"
                for resource in suggestion.resources {
                    suggestions += "- *\(resource.title)* by \(resource.author) (\(Int(resource.relevanceScore * 100))% relevance)\n"
                }
                suggestions += "\n"
            }
            
            suggestions += "---\n\n"
        }
        
        return suggestions
    }
    
    private func generateRoadmapSection(_ roadmap: PersonalizedLearningRoadmap) -> String {
        var roadmapText = ""
        
        roadmapText += "**Duration:** \(formatDuration(roadmap.totalDuration))  \n"
        roadmapText += "**Modules:** \(roadmap.modules.count)\n\n"
        
        // Personalized insights
        if !roadmap.personalizedInsights.isEmpty {
            roadmapText += "### Personalized Insights\n\n"
            
            if let focusAreas = roadmap.personalizedInsights["focusAreas"] as? [String] {
                roadmapText += "**Focus Areas:** \(focusAreas.joined(separator: ", "))\n\n"
            }
            
            if let weeklyGoal = roadmap.personalizedInsights["weeklyGoal"] as? String {
                roadmapText += "**This Week's Goal:** \(weeklyGoal)\n\n"
            }
        }
        
        // Learning modules
        roadmapText += "### Learning Modules\n\n"
        
        for (index, module) in roadmap.modules.enumerated() {
            roadmapText += "#### \(index + 1). \(module.title)\n\n"
            roadmapText += "**Duration:** \(formatTime(module.estimatedTime))  \n"
            roadmapText += "**Difficulty:** \(formatDifficulty(module.difficulty))\n\n"
            
            roadmapText += "**Objectives:**\n"
            for objective in module.objectives {
                roadmapText += "- \(objective)\n"
            }
            roadmapText += "\n"
            
            if !module.exercises.isEmpty {
                roadmapText += "**Exercises:**\n"
                for exercise in module.exercises {
                    roadmapText += "- **\(exercise.description):** \(exercise.instructions)\n"
                }
                roadmapText += "\n"
            }
        }
        
        return roadmapText
    }
    
    private func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .long
        formatter.timeStyle = .short
        return formatter.string(from: date)
    }
    
    private func formatDuration(_ duration: TimeInterval) -> String {
        let weeks = Int(duration / (7 * 24 * 3600))
        if weeks > 0 {
            return "\(weeks) week\(weeks == 1 ? "" : "s")"
        } else {
            let days = Int(duration / (24 * 3600))
            return "\(days) day\(days == 1 ? "" : "s")"
        }
    }
    
    private func formatTime(_ time: TimeInterval) -> String {
        let hours = Int(time / 3600)
        let minutes = Int((time.truncatingRemainder(dividingBy: 3600)) / 60)
        
        if hours > 0 {
            return "\(hours)h \(minutes)m"
        } else {
            return "\(minutes)m"
        }
    }
    
    private func formatDifficulty(_ difficulty: Double) -> String {
        switch difficulty {
        case 0..<0.3: return "Easy"
        case 0.3..<0.7: return "Medium"
        default: return "Hard"
        }
    }
}

// MARK: - HTML Report Generator

class HTMLReportGenerator {
    private let data: ExportData
    
    init(data: ExportData) {
        self.data = data
    }
    
    func generateReport() async throws -> String {
        var html = ""
        
        // HTML header
        html += generateHTMLHeader()
        
        // Body
        html += "<body>\n"
        html += "<div class=\"container\">\n"
        
        // Title
        html += "<header>\n"
        html += "<h1>Writing Analysis Report</h1>\n"
        html += "<p class=\"subtitle\">Generated on \(formatDate(data.generatedAt))</p>\n"
        html += "</header>\n\n"
        
        // Summary
        html += "<section class=\"summary\">\n"
        html += "<h2>Summary</h2>\n"
        html += generateHTMLSummary()
        html += "</section>\n\n"
        
        // Analysis
        if data.settings.includeAnalysis {
            html += "<section class=\"analysis\">\n"
            html += "<h2>Detailed Analysis</h2>\n"
            html += generateHTMLAnalysis()
            html += "</section>\n\n"
        }
        
        // Suggestions
        if data.settings.includeSuggestions && !data.analysis.improvementSuggestions.isEmpty {
            html += "<section class=\"suggestions\">\n"
            html += "<h2>Improvement Suggestions</h2>\n"
            html += generateHTMLSuggestions()
            html += "</section>\n\n"
        }
        
        // Roadmap
        if data.settings.includeLearningProgress, let roadmap = data.roadmap {
            html += "<section class=\"roadmap\">\n"
            html += "<h2>Learning Roadmap</h2>\n"
            html += generateHTMLRoadmap(roadmap)
            html += "</section>\n\n"
        }
        
        // Original text
        if data.settings.includeOriginalText && !data.originalText.isEmpty {
            html += "<section class=\"original-text\">\n"
            html += "<h2>Original Text</h2>\n"
            html += "<div class=\"text-box\">\n"
            html += "<pre>\(escapeHTML(data.originalText))</pre>\n"
            html += "</div>\n"
            html += "</section>\n\n"
        }
        
        // Footer
        html += "<footer>\n"
        html += "<p>Generated by Writing Coach App • Enhanced by Foundation Models</p>\n"
        html += "</footer>\n"
        
        html += "</div>\n"
        html += "</body>\n"
        html += "</html>\n"
        
        return html
    }
    
    private func generateHTMLHeader() -> String {
        return """
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Writing Analysis Report</title>
            <style>
                body {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    line-height: 1.6;
                    margin: 0;
                    padding: 20px;
                    background-color: #f5f5f5;
                    color: #333;
                }
                .container {
                    max-width: 800px;
                    margin: 0 auto;
                    background: white;
                    padding: 40px;
                    border-radius: 12px;
                    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                }
                header {
                    text-align: center;
                    margin-bottom: 40px;
                    padding-bottom: 20px;
                    border-bottom: 2px solid #007AFF;
                }
                h1 {
                    color: #007AFF;
                    margin: 0;
                    font-size: 2.5em;
                    font-weight: 700;
                }
                .subtitle {
                    color: #666;
                    margin: 10px 0 0 0;
                    font-style: italic;
                }
                h2 {
                    color: #007AFF;
                    border-bottom: 1px solid #eee;
                    padding-bottom: 10px;
                    margin-top: 40px;
                }
                h3 {
                    color: #333;
                    margin-top: 30px;
                }
                .metrics-table {
                    width: 100%;
                    border-collapse: collapse;
                    margin: 20px 0;
                    background: #f9f9f9;
                    border-radius: 8px;
                    overflow: hidden;
                }
                .metrics-table th,
                .metrics-table td {
                    padding: 12px;
                    text-align: left;
                    border-bottom: 1px solid #ddd;
                }
                .metrics-table th {
                    background: #007AFF;
                    color: white;
                    font-weight: 600;
                }
                .suggestion {
                    background: #f9f9f9;
                    padding: 20px;
                    border-radius: 8px;
                    margin: 20px 0;
                    border-left: 4px solid #007AFF;
                }
                .suggestion-meta {
                    display: flex;
                    gap: 20px;
                    margin: 10px 0;
                    font-size: 0.9em;
                    color: #666;
                }
                .example {
                    margin: 15px 0;
                    padding: 15px;
                    border-radius: 6px;
                }
                .example.before {
                    background: #ffebee;
                    border-left: 4px solid #f44336;
                }
                .example.after {
                    background: #e8f5e8;
                    border-left: 4px solid #4caf50;
                }
                .text-box {
                    background: #f9f9f9;
                    padding: 20px;
                    border-radius: 8px;
                    border: 1px solid #ddd;
                    margin: 20px 0;
                }
                .module {
                    background: #f9f9f9;
                    padding: 20px;
                    border-radius: 8px;
                    margin: 15px 0;
                    border-left: 4px solid #007AFF;
                }
                .assessment {
                    background: #f0f8ff;
                    padding: 20px;
                    border-radius: 8px;
                    border-left: 4px solid #007AFF;
                    margin: 20px 0;
                    font-style: italic;
                }
                footer {
                    text-align: center;
                    margin-top: 40px;
                    padding-top: 20px;
                    border-top: 1px solid #eee;
                    color: #666;
                    font-size: 0.9em;
                }
                ul {
                    padding-left: 20px;
                }
                li {
                    margin: 5px 0;
                }
            </style>
        </head>
        
        """
    }
    
    private func generateHTMLSummary() -> String {
        let metrics = data.analysis.metrics
        
        return """
        <table class="metrics-table">
            <thead>
                <tr>
                    <th>Metric</th>
                    <th>Value</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Readability Level</td>
                    <td>\(metrics.fleschKincaidLabel) (Grade \(String(format: "%.1f", metrics.fleschKincaidGrade)))</td>
                </tr>
                <tr>
                    <td>Average Sentence Length</td>
                    <td>\(String(format: "%.1f", metrics.averageSentenceLength)) words</td>
                </tr>
                <tr>
                    <td>Average Word Length</td>
                    <td>\(String(format: "%.1f", metrics.averageWordLength)) characters</td>
                </tr>
                <tr>
                    <td>Vocabulary Diversity</td>
                    <td>\(String(format: "%.0f%%", metrics.vocabularyDiversity * 100))</td>
                </tr>
                <tr>
                    <td>Improvement Areas</td>
                    <td>\(data.analysis.improvementSuggestions.count) suggestions</td>
                </tr>
            </tbody>
        </table>
        """
    }
    
    private func generateHTMLAnalysis() -> String {
        return """
        <div class="assessment">
            <h3>Overall Assessment</h3>
            <p>\(escapeHTML(data.analysis.assessment))</p>
        </div>
        
        <h3>Methodology</h3>
        <p>\(escapeHTML(data.analysis.methodology))</p>
        """
    }
    
    private func generateHTMLSuggestions() -> String {
        var html = ""
        
        for (index, suggestion) in data.analysis.improvementSuggestions.enumerated() {
            html += """
            <div class="suggestion">
                <h3>\(index + 1). \(escapeHTML(suggestion.title))</h3>
                <div class="suggestion-meta">
                    <span><strong>Area:</strong> \(suggestion.area.rawValue.capitalized)</span>
                    <span><strong>Priority:</strong> \(Int(suggestion.priority * 100))%</span>
                    <span><strong>Learning Effort:</strong> \(Int(suggestion.learningEffort * 100))%</span>
                </div>
                <p>\(escapeHTML(suggestion.description))</p>
                
                <div class="example before">
                    <strong>Before:</strong> \(escapeHTML(suggestion.beforeExample))
                </div>
                
                <div class="example after">
                    <strong>After:</strong> \(escapeHTML(suggestion.afterExample))
                </div>
            """
            
            if !suggestion.resources.isEmpty {
                html += "<h4>Recommended Resources:</h4><ul>"
                for resource in suggestion.resources {
                    html += "<li><em>\(escapeHTML(resource.title))</em> by \(escapeHTML(resource.author)) (\(Int(resource.relevanceScore * 100))% relevance)</li>"
                }
                html += "</ul>"
            }
            
            html += "</div>\n"
        }
        
        return html
    }
    
    private func generateHTMLRoadmap(_ roadmap: PersonalizedLearningRoadmap) -> String {
        var html = ""
        
        html += "<p><strong>Duration:</strong> \(formatDuration(roadmap.totalDuration)) • <strong>Modules:</strong> \(roadmap.modules.count)</p>"
        
        for (index, module) in roadmap.modules.enumerated() {
            html += """
            <div class="module">
                <h3>\(index + 1). \(escapeHTML(module.title))</h3>
                <p><strong>Duration:</strong> \(formatTime(module.estimatedTime)) • <strong>Difficulty:</strong> \(formatDifficulty(module.difficulty))</p>
                
                <h4>Objectives:</h4>
                <ul>
            """
            
            for objective in module.objectives {
                html += "<li>\(escapeHTML(objective))</li>"
            }
            
            html += "</ul>"
            
            if !module.exercises.isEmpty {
                html += "<h4>Exercises:</h4><ul>"
                for exercise in module.exercises {
                    html += "<li><strong>\(escapeHTML(exercise.description)):</strong> \(escapeHTML(exercise.instructions))</li>"
                }
                html += "</ul>"
            }
            
            html += "</div>"
        }
        
        return html
    }
    
    private func escapeHTML(_ string: String) -> String {
        return string
            .replacingOccurrences(of: "&", with: "&amp;")
            .replacingOccurrences(of: "<", with: "&lt;")
            .replacingOccurrences(of: ">", with: "&gt;")
            .replacingOccurrences(of: "\"", with: "&quot;")
            .replacingOccurrences(of: "'", with: "&#39;")
    }
    
    private func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .long
        formatter.timeStyle = .short
        return formatter.string(from: date)
    }
    
    private func formatDuration(_ duration: TimeInterval) -> String {
        let weeks = Int(duration / (7 * 24 * 3600))
        if weeks > 0 {
            return "\(weeks) week\(weeks == 1 ? "" : "s")"
        } else {
            let days = Int(duration / (24 * 3600))
            return "\(days) day\(days == 1 ? "" : "s")"
        }
    }
    
    private func formatTime(_ time: TimeInterval) -> String {
        let hours = Int(time / 3600)
        let minutes = Int((time.truncatingRemainder(dividingBy: 3600)) / 60)
        
        if hours > 0 {
            return "\(hours)h \(minutes)m"
        } else {
            return "\(minutes)m"
        }
    }
    
    private func formatDifficulty(_ difficulty: Double) -> String {
        switch difficulty {
        case 0..<0.3: return "Easy"
        case 0.3..<0.7: return "Medium"
        default: return "Hard"
        }
    }
}

// MARK: - Text Report Generator

class TextReportGenerator {
    private let data: ExportData
    
    init(data: ExportData) {
        self.data = data
    }
    
    func generateReport() async throws -> String {
        var text = ""
        
        // Header
        text += "WRITING ANALYSIS REPORT\n"
        text += "======================\n\n"
        text += "Generated on \(formatDate(data.generatedAt))\n\n"
        text += "---\n\n"
        
        // Summary
        text += "SUMMARY\n"
        text += "-------\n\n"
        text += generateTextSummary()
        text += "\n"
        
        // Analysis
        if data.settings.includeAnalysis {
            text += "DETAILED ANALYSIS\n"
            text += "-----------------\n\n"
            text += generateTextAnalysis()
            text += "\n"
        }
        
        // Suggestions
        if data.settings.includeSuggestions && !data.analysis.improvementSuggestions.isEmpty {
            text += "IMPROVEMENT SUGGESTIONS\n"
            text += "-----------------------\n\n"
            text += generateTextSuggestions()
            text += "\n"
        }
        
        // Roadmap
        if data.settings.includeLearningProgress, let roadmap = data.roadmap {
            text += "LEARNING ROADMAP\n"
            text += "----------------\n\n"
            text += generateTextRoadmap(roadmap)
            text += "\n"
        }
        
        // Original text
        if data.settings.includeOriginalText && !data.originalText.isEmpty {
            text += "ORIGINAL TEXT\n"
            text += "-------------\n\n"
            text += data.originalText
            text += "\n\n"
        }
        
        // Footer
        text += "---\n\n"
        text += "Generated by Writing Coach App • Enhanced by Foundation Models\n"
        
        return text
    }
    
    private func generateTextSummary() -> String {
        let metrics = data.analysis.metrics
        var summary = ""
        
        summary += "Readability Level: \(metrics.fleschKincaidLabel) (Grade \(String(format: "%.1f", metrics.fleschKincaidGrade)))\n"
        summary += "Average Sentence Length: \(String(format: "%.1f", metrics.averageSentenceLength)) words\n"
        summary += "Average Word Length: \(String(format: "%.1f", metrics.averageWordLength)) characters\n"
        summary += "Vocabulary Diversity: \(String(format: "%.0f%%", metrics.vocabularyDiversity * 100))\n"
        summary += "Improvement Areas: \(data.analysis.improvementSuggestions.count) suggestions\n"
        
        return summary
    }
    
    private func generateTextAnalysis() -> String {
        var analysis = ""
        
        analysis += "Overall Assessment:\n"
        analysis += data.analysis.assessment + "\n\n"
        
        analysis += "Methodology:\n"
        analysis += data.analysis.methodology + "\n"
        
        return analysis
    }
    
    private func generateTextSuggestions() -> String {
        var suggestions = ""
        
        for (index, suggestion) in data.analysis.improvementSuggestions.enumerated() {
            suggestions += "\(index + 1). \(suggestion.title)\n"
            suggestions += "   Area: \(suggestion.area.rawValue.capitalized)\n"
            suggestions += "   Priority: \(Int(suggestion.priority * 100))%\n"
            suggestions += "   Learning Effort: \(Int(suggestion.learningEffort * 100))%\n\n"
            
            suggestions += "   \(suggestion.description)\n\n"
            
            suggestions += "   Before: \(suggestion.beforeExample)\n"
            suggestions += "   After:  \(suggestion.afterExample)\n\n"
            
            if !suggestion.resources.isEmpty {
                suggestions += "   Recommended Resources:\n"
                for resource in suggestion.resources {
                    suggestions += "   - \(resource.title) by \(resource.author) (\(Int(resource.relevanceScore * 100))% relevance)\n"
                }
                suggestions += "\n"
            }
            
            suggestions += "   " + String(repeating: "-", count: 50) + "\n\n"
        }
        
        return suggestions
    }
    
    private func generateTextRoadmap(_ roadmap: PersonalizedLearningRoadmap) -> String {
        var roadmapText = ""
        
        roadmapText += "Duration: \(formatDuration(roadmap.totalDuration))\n"
        roadmapText += "Modules: \(roadmap.modules.count)\n\n"
        
        for (index, module) in roadmap.modules.enumerated() {
            roadmapText += "\(index + 1). \(module.title)\n"
            roadmapText += "   Duration: \(formatTime(module.estimatedTime))\n"
            roadmapText += "   Difficulty: \(formatDifficulty(module.difficulty))\n\n"
            
            roadmapText += "   Objectives:\n"
            for objective in module.objectives {
                roadmapText += "   - \(objective)\n"
            }
            roadmapText += "\n"
            
            if !module.exercises.isEmpty {
                roadmapText += "   Exercises:\n"
                for exercise in module.exercises {
                    roadmapText += "   - \(exercise.description): \(exercise.instructions)\n"
                }
                roadmapText += "\n"
            }
        }
        
        return roadmapText
    }
    
    private func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .long
        formatter.timeStyle = .short
        return formatter.string(from: date)
    }
    
    private func formatDuration(_ duration: TimeInterval) -> String {
        let weeks = Int(duration / (7 * 24 * 3600))
        if weeks > 0 {
            return "\(weeks) week\(weeks == 1 ? "" : "s")"
        } else {
            let days = Int(duration / (24 * 3600))
            return "\(days) day\(days == 1 ? "" : "s")"
        }
    }
    
    private func formatTime(_ time: TimeInterval) -> String {
        let hours = Int(time / 3600)
        let minutes = Int((time.truncatingRemainder(dividingBy: 3600)) / 60)
        
        if hours > 0 {
            return "\(hours)h \(minutes)m"
        } else {
            return "\(minutes)m"
        }
    }
    
    private func formatDifficulty(_ difficulty: Double) -> String {
        switch difficulty {
        case 0..<0.3: return "Easy"
        case 0.3..<0.7: return "Medium"
        default: return "Hard"
        }
    }
}